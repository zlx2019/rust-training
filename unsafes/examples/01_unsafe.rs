/// unsafe 是什么？
///   几乎每个语言都支持 unsafe 特性, 特指一些 '不安全' 操作。鱼和熊掌不可兼得，一般来说 安全性就意味着会有很多限制性
/// 但有时候我们也需要突破一些限制，来实现一些更高效更底层的机制, 这种行为一般称之为 unsafe 行为。
/// 
///   Rust 的一个主要定位就是系统编程，众所周知，系统编程就是底层编程，往往需要直接跟操作系统打交道，甚至于去实现一个操作系统。
/// 而为了实现底层系统编程，unsafe 就是必不可少的。
/// 
///   所以在Rust中，unsafe 并不意味着不安全，而是将安全责任转移给了开发者，从而避免编译器的安全检查。
fn main(){
    // 使用 unsafe 非常简单
    let n = 5 ;

    // 获取 n 的裸指针, 也称之为 常量指针
    // 它具有破坏Rust安全的能力，所以只能在 unsafe 块内使用
    let ncp = &n as *const i32;
    unsafe{
        println!("ncp is {}", *ncp)
    }
}