/// 参考:
///     - https://tokio.rs/blog/2019-10-scheduler#the-next-generation-tokio-scheduler
///     - https://rust-book.junmajinlong.com/ch100/01_understand_tokio_runtime.html
/// 
/// Tokio Runtime 提供了如下几种组件:
///     - 异步IO驱动(I/O Driver)
///     - 异步定时器(Timer)
///     - 任务调度器(Scheduler)
///     - Reactor事件循环(Event Loop)
///   
///   每创建一个Runtime时,就在这个Runtime创建一个 Reactor 和 Scheduler,同时还创建了一个任务队列。
///   当一个异步任务需要运行时，这个任务要被放入任务就绪队列，然后等待被Scheduler所调度。
///   当一个异步任务产生阻塞时，这个任务会被放入任务阻塞队列，然后等待 Reactor 收到对应的事件通知(比如IO完成的通知、睡眠结束的通知)来唤醒，
/// 当任务被唤醒后，它将被重新放入就绪队列，等待被调度。
/// 
///   就绪队列中的每一个任务都是可运行的任务，可随时被调度器调度选中。调度时会选择哪一个任务，是调度器根据调度算法去决定的。某个任务被调度选中后，
/// 调度器将分配一个线程去执行该任务。
/// 
///   大方向上来说，有两种调度策略：抢占式调度和协作式调度。抢占式调度策略，调度器会在合适的时候(调度规则决定什么是合适的时候)
/// 强行切换当前正在执行的调度单元(例如进程、线程)，避免某个任务长时间霸占CPU从而导致其它任务出现饥饿。协作式调度策略则不会强行切断当前正在执行的单元，
/// 只有执行单元执行完任务或主动放弃CPU，才会将该执行单元重新排队等待下次调度，这可能会导致某个长时间计算的任务霸占CPU，但是可以让任务充分执行尽早完成，
/// 而不会被中断。
/// 
///   对于面向大众使用的操作系统(如Linux)通常采用抢占式调度策略来保证系统安全，避免恶意程序霸占CPU。而对于语言层面来说，通常采用协作式调度策略，
/// 这样既有底层OS的抢占式保底，又有协作式的高效。tokio的调度策略是协作式调度策略。
///   
/// 
fn main(){}